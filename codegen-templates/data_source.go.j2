// Code generated by generate.py. DO NOT EDIT.
{% from "macros.j2" import response_mapping %}

package generated

import (
	"context"
	"fmt"
	"net/url"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Single {{ resource.name }} data source

var _ datasource.DataSource = &{{ resource.name }}DataSource{}

func New{{ resource.name }}DataSource() datasource.DataSource {
	return &{{ resource.name }}DataSource{}
}

type {{ resource.name }}DataSource struct {
	client Client
}

func (d *{{ resource.name }}DataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ resource.tf_name }}"
}

func (d *{{ resource.name }}DataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = {{ resource.name }}DataSourceSchema(ctx)
}

func (d *{{ resource.name }}DataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected Client, got: %T", req.ProviderData),
		)
		return
	}

	d.client = client
}

func (d *{{ resource.name }}DataSource) Read(ctx context.Context, req datasource.ReadRequest, response *datasource.ReadResponse) {
	var data {{ resource.name }}Model
	response.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if response.Diagnostics.HasError() {
		return
	}

	path := fmt.Sprintf("{{ resource.path }}{{ id_format }}", data.ID.{{ id_value_method }})
	var resp {{ resource.name }}Response
	err := d.client.Read(path, &resp)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read {{ resource.tf_name }}: %s", err))
		return
	}

{{ response_mapping(resource.fields, "resp", "data", "\t") }}

{% if resource.store_post_response %}
	// invitation is not available from data source (only returned on resource creation)
	data.Invitation = types.StringNull()
{% endif %}
{% if resource.has_groups %}
	// Fetch groups for this resource
	var groupsResp []GroupMembership
	if err := d.client.GetGroupsRaw("{{ resource.path }}", data.ID.{{ id_value_method }}, &groupsResp); err == nil {
		groupsList, diags := groupsToTerraformList(ctx, groupsResp)
		response.Diagnostics.Append(diags...)
		data.Groups = groupsList
	} else {
		data.Groups = types.ListNull(types.ObjectType{AttrTypes: groupMembershipAttrTypes()})
	}
{% endif %}

	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

// {{ resource.plural }} list data source

type {{ resource.plural }}Model struct {
{% for qp in resource.query_params %}
{% if qp.is_list %}
	{{ qp.go_name }} types.List `tfsdk:"{{ qp.tf_name }}"`
{% else %}
	{{ qp.go_name }} types.{{ qp.tf_type }} `tfsdk:"{{ qp.tf_name }}"`
{% endif %}
{% endfor %}
	{{ resource.plural }} types.List `tfsdk:"{{ resource.tf_plural_name }}"`
}

var _ datasource.DataSource = &{{ resource.plural }}DataSource{}

func New{{ resource.plural }}DataSource() datasource.DataSource {
	return &{{ resource.plural }}DataSource{}
}

type {{ resource.plural }}DataSource struct {
	client Client
}

func (d *{{ resource.plural }}DataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ resource.tf_plural_name }}"
}

func (d *{{ resource.plural }}DataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = {{ resource.plural }}DataSourceSchema(ctx)
}

func (d *{{ resource.plural }}DataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected Client, got: %T", req.ProviderData),
		)
		return
	}

	d.client = client
}

func (d *{{ resource.plural }}DataSource) Read(ctx context.Context, req datasource.ReadRequest, response *datasource.ReadResponse) {
	var data {{ resource.plural }}Model
	response.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if response.Diagnostics.HasError() {
		return
	}

	params := url.Values{}
{% for qp in resource.query_params %}
{% if qp.is_list %}
	if !data.{{ qp.go_name }}.IsNull() && !data.{{ qp.go_name }}.IsUnknown() {
{% if qp.tf_type == "String" %}
		var {{ qp.tf_name }} []string
{% else %}
		var {{ qp.tf_name }} []int64
{% endif %}
		response.Diagnostics.Append(data.{{ qp.go_name }}.ElementsAs(ctx, &{{ qp.tf_name }}, false)...)
		for _, v := range {{ qp.tf_name }} {
{% if qp.tf_type == "String" %}
			params.Add("{{ qp.name }}", v)
{% else %}
			params.Add("{{ qp.name }}", fmt.Sprintf("%d", v))
{% endif %}
		}
	}
{% else %}
	if !data.{{ qp.go_name }}.IsNull() && !data.{{ qp.go_name }}.IsUnknown() {
{% if qp.tf_type == "String" %}
		params.Add("{{ qp.name }}", data.{{ qp.go_name }}.ValueString())
{% elif qp.tf_type == "Int64" %}
		params.Add("{{ qp.name }}", fmt.Sprintf("%d", data.{{ qp.go_name }}.ValueInt64()))
{% elif qp.tf_type == "Bool" %}
		params.Add("{{ qp.name }}", fmt.Sprintf("%t", data.{{ qp.go_name }}.ValueBool()))
{% endif %}
	}
{% endif %}
{% endfor %}

	if response.Diagnostics.HasError() {
		return
	}

	var results []{{ resource.name }}Response
	err := d.client.ListWithMultiParams("{{ resource.path }}", params, &results)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to list {{ resource.tf_plural_name }}: %s", err))
		return
	}

	items := make([]{{ resource.name }}Model, len(results))
	for i, resp := range results {
		item := &items[i]
{{ response_mapping(resource.fields, "resp", "item", "\t\t") }}
{% if resource.store_post_response %}
		// invitation is not available from data source (only returned on resource creation)
		item.Invitation = types.StringNull()
{% endif %}
{% if resource.has_groups %}
		// groups are not fetched in list data source
		item.Groups = types.ListNull(types.ObjectType{AttrTypes: groupMembershipAttrTypes()})
{% endif %}
	}

	listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{ resource.tf_name }}AttrTypes()}, items)
	response.Diagnostics.Append(diags...)
	data.{{ resource.plural }} = listVal

	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

func {{ resource.tf_name }}AttrTypes() map[string]attr.Type {
	return map[string]attr.Type{
{% for field in resource.fields %}
{% if field.is_nested and field.is_list and field.nested_fields %}
		"{{ field.tf_name }}": types.SetType{ElemType: types.ObjectType{AttrTypes: map[string]attr.Type{
{% for nf in field.nested_fields %}
{% if nf.is_list %}
			"{{ nf.tf_name }}": types.SetType{ElemType: {{ nf.tf_element_type }}},
{% else %}
			"{{ nf.tf_name }}": types.{{ nf.tf_type }}Type,
{% endif %}
{% endfor %}
		}}},
{% elif not field.is_nested %}
{% if field.is_list %}
		"{{ field.tf_name }}": types.SetType{ElemType: {{ field.tf_element_type }}},
{% elif field.is_map %}
		"{{ field.tf_name }}": types.MapType{ElemType: {{ field.tf_element_type }}},
{% else %}
		"{{ field.tf_name }}": types.{{ field.tf_type }}Type,
{% endif %}
{% endif %}
{% endfor %}
{% if resource.store_post_response %}
		"invitation": types.StringType,
{% endif %}
{% if resource.has_groups %}
		"groups": types.ListType{ElemType: types.ObjectType{AttrTypes: groupMembershipAttrTypes()}},
{% endif %}
	}
}
