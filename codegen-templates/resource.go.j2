// Code generated by generate.py. DO NOT EDIT.
{% from "macros.j2" import response_mapping %}

package {{ package_name }}

import (
{% if resource.store_post_response %}
	"encoding/base64"
{% endif %}
	"context"
	"encoding/json"
	"fmt"
{% if resource.id_type == "int64" %}
	"strconv"
{% endif %}

{% if has_nested_list_fields %}
	"github.com/hashicorp/terraform-plugin-framework/attr"
{% endif %}
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

var _ resource.Resource = &{{ resource.name }}Resource{}
var _ resource.ResourceWithImportState = &{{ resource.name }}Resource{}

func New{{ resource.name }}Resource() resource.Resource {
	return &{{ resource.name }}Resource{}
}

type {{ resource.name }}Resource struct {
	client Client
}

func (r *{{ resource.name }}Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ resource.tf_name }}"
}

func (r *{{ resource.name }}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = {{ resource.name }}ResourceSchema(ctx)
}

func (r *{{ resource.name }}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected Client, got: %T", req.ProviderData),
		)
		return
	}

	r.client = client
}

func (r *{{ resource.name }}Resource) Create(ctx context.Context, req resource.CreateRequest, response *resource.CreateResponse) {
	var data {{ resource.name }}Model
	response.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if response.Diagnostics.HasError() {
		return
	}

	// Build create request
{% if required_fields %}
	createReq := &{{ resource.name }}CreateRequest{
{% for field in required_fields %}
{% if field.is_pointer %}
{% if field.tf_type == "String" %}
		{{ field.name }}: func() *string { v := data.{{ field.name }}.ValueString(); return &v }(),
{% elif field.tf_type == "Int64" %}
		{{ field.name }}: func() *int64 { v := data.{{ field.name }}.ValueInt64(); return &v }(),
{% elif field.tf_type == "Bool" %}
		{{ field.name }}: func() *bool { v := data.{{ field.name }}.ValueBool(); return &v }(),
{% endif %}
{% else %}
{% if field.tf_type == "String" %}
		{{ field.name }}: data.{{ field.name }}.ValueString(),
{% elif field.tf_type == "Int64" %}
		{{ field.name }}: data.{{ field.name }}.ValueInt64(),
{% elif field.tf_type == "Bool" %}
		{{ field.name }}: data.{{ field.name }}.ValueBool(),
{% endif %}
{% endif %}
{% endfor %}
	}
{% else %}
	createReq := &{{ resource.name }}CreateRequest{}
{% endif %}
{% for field in nullable_required_fields %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
{% if field.tf_type == "String" %}
		v := data.{{ field.name }}.ValueString()
{% elif field.tf_type == "Int64" %}
		v := data.{{ field.name }}.ValueInt64()
{% elif field.tf_type == "Bool" %}
		v := data.{{ field.name }}.ValueBool()
{% endif %}
		createReq.{{ field.name }} = &v
	}
	// {{ field.name }} is nullable-required: null is sent if not set (API auto-assigns)
{% endfor %}
{% for field in required_list_fields %}
	// Required list field - always send (even if empty)
{% if field.tf_element_type == "types.StringType" %}
	var {{ field.tf_name }} []string
{% else %}
	var {{ field.tf_name }} []int64
{% endif %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
		response.Diagnostics.Append(data.{{ field.name }}.ElementsAs(ctx, &{{ field.tf_name }}, false)...)
	}
	createReq.{{ field.name }} = {{ field.tf_name }}
{% endfor %}
{% for field in optional_fields %}
{% if field.is_list %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
{% if field.tf_element_type == "types.StringType" %}
		var {{ field.tf_name }} []string
{% else %}
		var {{ field.tf_name }} []int64
{% endif %}
		response.Diagnostics.Append(data.{{ field.name }}.ElementsAs(ctx, &{{ field.tf_name }}, false)...)
		createReq.{{ field.name }} = {{ field.tf_name }}
	}
{% elif field.is_map %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
		{{ field.tf_name }} := make(map[string]string)
		response.Diagnostics.Append(data.{{ field.name }}.ElementsAs(ctx, &{{ field.tf_name }}, false)...)
		createReq.{{ field.name }} = {{ field.tf_name }}
	}
{% else %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
{% if field.tf_type == "String" %}
		v := data.{{ field.name }}.ValueString()
{% elif field.tf_type == "Int64" %}
		v := data.{{ field.name }}.ValueInt64()
{% elif field.tf_type == "Bool" %}
		v := data.{{ field.name }}.ValueBool()
{% endif %}
		createReq.{{ field.name }} = &v
	}
{% endif %}
{% endfor %}
{% for field in nested_list_fields %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
		var {{ field.tf_name }}Raw []types.Object
		response.Diagnostics.Append(data.{{ field.name }}.ElementsAs(ctx, &{{ field.tf_name }}Raw, false)...)
		{{ field.tf_name }} := make([]{{ field.nested_ref }}, len({{ field.tf_name }}Raw))
		for i, obj := range {{ field.tf_name }}Raw {
{% for nf in field.nested_fields %}
{% if nf.tf_type == "String" %}
			{{ field.tf_name }}[i].{{ nf.name }} = obj.Attributes()["{{ nf.tf_name }}"].(types.String).ValueString()
{% elif nf.tf_type == "Int64" %}
			{{ field.tf_name }}[i].{{ nf.name }} = obj.Attributes()["{{ nf.tf_name }}"].(types.Int64).ValueInt64()
{% elif nf.tf_type == "Bool" %}
			{{ field.tf_name }}[i].{{ nf.name }} = obj.Attributes()["{{ nf.tf_name }}"].(types.Bool).ValueBool()
{% elif nf.is_list %}
{% if nf.tf_element_type == "types.StringType" %}
			if set, ok := obj.Attributes()["{{ nf.tf_name }}"].(types.Set); ok && !set.IsNull() {
				var vals []string
				set.ElementsAs(ctx, &vals, false)
				{{ field.tf_name }}[i].{{ nf.name }} = vals
			}
{% else %}
			if set, ok := obj.Attributes()["{{ nf.tf_name }}"].(types.Set); ok && !set.IsNull() {
				var vals []int64
				set.ElementsAs(ctx, &vals, false)
				{{ field.tf_name }}[i].{{ nf.name }} = vals
			}
{% endif %}
{% endif %}
{% endfor %}
		}
		createReq.{{ field.name }} = {{ field.tf_name }}
	}
{% endfor %}

	if response.Diagnostics.HasError() {
		return
	}

	postResp, err := r.client.CreateRaw("{{ resource.path }}", createReq)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create {{ resource.tf_name }}: %s", err))
		return
	}

{% if resource.store_post_response %}
	// Store POST response as base64
	data.Invitation = types.StringValue(base64.StdEncoding.EncodeToString(postResp))

{% endif %}
	// Extract ID from POST response
	var postResult map[string]interface{}
	if err := json.Unmarshal(postResp, &postResult); err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to parse create response: %s", err))
		return
	}

{% if resource.id_type == "string" %}
	id, ok := postResult["{{ resource.post_id_field }}"].(string)
	if !ok {
		response.Diagnostics.AddError("Client Error", "POST response missing {{ resource.post_id_field }} field")
		return
	}
{% else %}
	idFloat, ok := postResult["{{ resource.post_id_field }}"].(float64)
	if !ok {
		response.Diagnostics.AddError("Client Error", "POST response missing {{ resource.post_id_field }} field")
		return
	}
	id := int64(idFloat)
{% endif %}

	// GET the full entity
	getPath := fmt.Sprintf("{{ resource.path }}{{ id_format }}", id)
	var resp {{ resource.name }}Response
	err = r.client.Read(getPath, &resp)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read created {{ resource.tf_name }}: %s", err))
		return
	}

	data.ID = {{ id_set }}(resp.ID)
{{ response_mapping(resource.fields, "resp", "data", "\t") }}
{% if resource.has_groups %}

	// Handle groups
	if !data.Groups.IsNull() && !data.Groups.IsUnknown() {
		plannedGroups, err := terraformListToGroups(ctx, data.Groups)
		if err != nil {
			response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to parse groups: %s", err))
			return
		}
		if plannedGroups != nil {
			var updatedGroups []GroupMembership
			err = r.client.UpdateGroupsRaw("{{ resource.path }}", id, plannedGroups, &updatedGroups)
			if err != nil {
				response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update {{ resource.tf_name }} groups: %s", err))
				return
			}
		}
	}

	// Fetch groups from API
	var groups []GroupMembership
	err = r.client.GetGroupsRaw("{{ resource.path }}", id, &groups)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read {{ resource.tf_name }} groups: %s", err))
		return
	}
	groupsVal, diags := groupsToTerraformList(ctx, groups)
	response.Diagnostics.Append(diags...)
	data.Groups = groupsVal
{% endif %}

	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

func (r *{{ resource.name }}Resource) Read(ctx context.Context, req resource.ReadRequest, response *resource.ReadResponse) {
	var data {{ resource.name }}Model
	response.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if response.Diagnostics.HasError() {
		return
	}

{% if resource.store_post_response %}
	// Preserve invitation from state (not returned by GET)
	var stateData {{ resource.name }}Model
	response.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

{% endif %}
	path := fmt.Sprintf("{{ resource.path }}{{ id_format }}", data.ID.{{ id_value_method }})
	var resp {{ resource.name }}Response
	err := r.client.Read(path, &resp)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read {{ resource.tf_name }}: %s", err))
		return
	}

{{ response_mapping(resource.fields, "resp", "data", "\t") }}
{% if resource.store_post_response %}

	// Restore invitation from state
	data.Invitation = stateData.Invitation
{% endif %}
{% if resource.has_groups %}

	// Fetch groups from API
	id := data.ID.{{ id_value_method }}
	var groups []GroupMembership
	err = r.client.GetGroupsRaw("{{ resource.path }}", id, &groups)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read {{ resource.tf_name }} groups: %s", err))
		return
	}
	groupsVal, diags := groupsToTerraformList(ctx, groups)
	response.Diagnostics.Append(diags...)
	data.Groups = groupsVal
{% endif %}

	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

func (r *{{ resource.name }}Resource) Update(ctx context.Context, req resource.UpdateRequest, response *resource.UpdateResponse) {
	var data {{ resource.name }}Model
	response.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if response.Diagnostics.HasError() {
		return
	}

	updateReq := make(map[string]interface{})
{% for field in resource.create_fields %}
{% if not field.is_nested %}
{% if field.is_list %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
{% if field.tf_element_type == "types.StringType" %}
		var {{ field.tf_name }} []string
{% else %}
		var {{ field.tf_name }} []int64
{% endif %}
		response.Diagnostics.Append(data.{{ field.name }}.ElementsAs(ctx, &{{ field.tf_name }}, false)...)
		updateReq["{{ field.json_name }}"] = {{ field.tf_name }}
	}
{% elif field.is_map %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
		{{ field.tf_name }} := make(map[string]string)
		response.Diagnostics.Append(data.{{ field.name }}.ElementsAs(ctx, &{{ field.tf_name }}, false)...)
		updateReq["{{ field.json_name }}"] = {{ field.tf_name }}
	}
{% else %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
{% if field.tf_type == "String" %}
		updateReq["{{ field.json_name }}"] = data.{{ field.name }}.ValueString()
{% elif field.tf_type == "Int64" %}
		updateReq["{{ field.json_name }}"] = data.{{ field.name }}.ValueInt64()
{% elif field.tf_type == "Bool" %}
		updateReq["{{ field.json_name }}"] = data.{{ field.name }}.ValueBool()
{% endif %}
	}
{% endif %}
{% endif %}
{% endfor %}
{% for field in nested_list_fields %}
	if !data.{{ field.name }}.IsNull() && !data.{{ field.name }}.IsUnknown() {
		var {{ field.tf_name }}Raw []types.Object
		response.Diagnostics.Append(data.{{ field.name }}.ElementsAs(ctx, &{{ field.tf_name }}Raw, false)...)
		{{ field.tf_name }} := make([]map[string]interface{}, len({{ field.tf_name }}Raw))
		for i, obj := range {{ field.tf_name }}Raw {
			{{ field.tf_name }}[i] = make(map[string]interface{})
{% for nf in field.nested_fields %}
{% if nf.tf_type == "String" %}
			{{ field.tf_name }}[i]["{{ nf.json_name }}"] = obj.Attributes()["{{ nf.tf_name }}"].(types.String).ValueString()
{% elif nf.tf_type == "Int64" %}
			{{ field.tf_name }}[i]["{{ nf.json_name }}"] = obj.Attributes()["{{ nf.tf_name }}"].(types.Int64).ValueInt64()
{% elif nf.tf_type == "Bool" %}
			{{ field.tf_name }}[i]["{{ nf.json_name }}"] = obj.Attributes()["{{ nf.tf_name }}"].(types.Bool).ValueBool()
{% elif nf.is_list %}
{% if nf.tf_element_type == "types.StringType" %}
			if set, ok := obj.Attributes()["{{ nf.tf_name }}"].(types.Set); ok && !set.IsNull() {
				var vals []string
				set.ElementsAs(ctx, &vals, false)
				{{ field.tf_name }}[i]["{{ nf.json_name }}"] = vals
			}
{% else %}
			if set, ok := obj.Attributes()["{{ nf.tf_name }}"].(types.Set); ok && !set.IsNull() {
				var vals []int64
				set.ElementsAs(ctx, &vals, false)
				{{ field.tf_name }}[i]["{{ nf.json_name }}"] = vals
			}
{% endif %}
{% endif %}
{% endfor %}
		}
		updateReq["{{ field.json_name }}"] = {{ field.tf_name }}
	}
{% endfor %}

	if response.Diagnostics.HasError() {
		return
	}

	// Get state data for ID (computed fields aren't in the plan)
	var stateData {{ resource.name }}Model
	response.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

	path := fmt.Sprintf("{{ resource.path }}{{ id_format }}", stateData.ID.{{ id_value_method }})
	var resp {{ resource.name }}Response
	err := r.client.Update(path, updateReq, &resp)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update {{ resource.tf_name }}: %s", err))
		return
	}

{{ response_mapping(resource.fields, "resp", "data", "\t") }}
{% if resource.store_post_response %}

	// Restore invitation from state
	data.Invitation = stateData.Invitation
{% endif %}
{% if resource.has_groups %}

	// Handle groups
	id := data.ID.{{ id_value_method }}
	if !data.Groups.IsNull() && !data.Groups.IsUnknown() {
		plannedGroups, err := terraformListToGroups(ctx, data.Groups)
		if err != nil {
			response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to parse groups: %s", err))
			return
		}
		if plannedGroups != nil {
			var updatedGroups []GroupMembership
			err = r.client.UpdateGroupsRaw("{{ resource.path }}", id, plannedGroups, &updatedGroups)
			if err != nil {
				response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update {{ resource.tf_name }} groups: %s", err))
				return
			}
		}
	}

	// Fetch groups from API
	var groups []GroupMembership
	err = r.client.GetGroupsRaw("{{ resource.path }}", id, &groups)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read {{ resource.tf_name }} groups: %s", err))
		return
	}
	groupsVal, diags := groupsToTerraformList(ctx, groups)
	response.Diagnostics.Append(diags...)
	data.Groups = groupsVal
{% endif %}

	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

func (r *{{ resource.name }}Resource) Delete(ctx context.Context, req resource.DeleteRequest, response *resource.DeleteResponse) {
	var data {{ resource.name }}Model
	response.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if response.Diagnostics.HasError() {
		return
	}

	path := fmt.Sprintf("{{ resource.path }}{{ id_format }}", data.ID.{{ id_value_method }})
	err := r.client.Delete(path)
	if err != nil {
		response.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete {{ resource.tf_name }}: %s", err))
		return
	}
}

func (r *{{ resource.name }}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
{% if resource.id_type == "int64" %}
	id, err := strconv.ParseInt(req.ID, 10, 64)
	if err != nil {
		resp.Diagnostics.AddError("Invalid ID", fmt.Sprintf("Unable to parse ID as integer: %s", err))
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), id)...)
{% else %}
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
{% endif %}
}
